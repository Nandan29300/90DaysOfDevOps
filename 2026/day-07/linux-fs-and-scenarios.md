# Day 07 â€“ Linux File System Hierarchy & Scenario-Based Practice

## ðŸ“‹ Overview
Today's goal is to **understand where things live in Linux** and **practice troubleshooting like a DevOps engineer**.

---

## ðŸŽ¯ Learning Objectives
By the end of today, you should understand:
- Linux File System Hierarchy (the most important directories)
- How to solve real-world scenarios step by step
- Where to find logs, configs, and binaries
- Troubleshooting flow and methodology

---

# Part 1: Linux File System Hierarchy

## Core Directories (Must Know)

### `/` (root) - The Starting Point of Everything
**Purpose:** The top-level directory from which all other directories branch out. Everything in Linux starts here.

**Hands-on Check:**
```bash
ls -l /
```

**Common contents:**
- `bin/` - Essential binaries
- `etc/` - Configuration files
- `home/` - User directories
- `var/` - Variable data

**I would use this when:** Navigating the absolute path of any file or understanding the complete directory structure.

---

### `/home` - User Home Directories
**Purpose:** Contains personal directories for all regular users on the system. Each user has their own subdirectory (e.g., `/home/john`, `/home/sarah`).

**Hands-on Check:**
```bash
ls -l /home
ls -la ~
```

**Common contents:**
- User documents
- Personal configurations (.bashrc, .profile)
- Desktop files
- Downloads

**I would use this when:** Accessing user-specific files, scripts, or configurations for non-root users.

---

### `/root` - Root User's Home Directory
**Purpose:** The home directory for the root (superuser) account. Separate from `/home` for security reasons.

**Hands-on Check:**
```bash
sudo ls -la /root
```

**Common contents:**
- Root's personal files
- Administrative scripts
- Root's configuration files

**I would use this when:** Working as root user or storing system administration scripts that should only be accessible to root.

---

### `/etc` - Configuration Files
**Purpose:** Contains system-wide configuration files and shell scripts used to boot and initialize system settings.

**Hands-on Check:**
```bash
ls -l /etc
cat /etc/hostname
cat /etc/os-release
```

**Common contents:**
- `/etc/passwd` - User account information
- `/etc/hosts` - Hostname to IP mappings
- `/etc/nginx/` - Nginx web server configs
- `/etc/ssh/` - SSH configuration
- `/etc/systemd/` - Systemd service configurations

**I would use this when:** Modifying system configurations, checking service settings, or troubleshooting configuration-related issues.

---

### `/var/log` - Log Files (Very Important for DevOps!)
**Purpose:** Contains log files generated by the system, applications, and services. Critical for troubleshooting and monitoring.

**Hands-on Check:**
```bash
ls -l /var/log
# Find the largest log files
du -sh /var/log/* 2>/dev/null | sort -h | tail -5
# View system log
sudo tail -f /var/log/syslog  # Ubuntu/Debian
sudo tail -f /var/log/messages  # RedHat/CentOS
```

**Common contents:**
- `/var/log/syslog` or `/var/log/messages` - System logs
- `/var/log/auth.log` - Authentication logs
- `/var/log/nginx/` - Nginx logs
- `/var/log/apache2/` - Apache logs
- `/var/log/kern.log` - Kernel logs

**I would use this when:** Debugging application errors, investigating security incidents, monitoring system health, or troubleshooting service failures.

---

### `/tmp` - Temporary Files
**Purpose:** Stores temporary files created by system and users. Contents are typically cleared on reboot.

**Hands-on Check:**
```bash
ls -l /tmp
df -h /tmp
```

**Common contents:**
- Session files
- Temporary application data
- Lock files
- Cache files

**I would use this when:** Storing temporary data during script execution, testing, or when applications need scratch space.

---

## Additional Directories (Good to Know)

### `/bin` - Essential Command Binaries
**Purpose:** Contains essential command-line binaries needed for system boot and repair. Available to all users.

**Hands-on Check:**
```bash
ls -l /bin
which ls
which bash
```

**Common contents:**
- `ls`, `cp`, `mv` - File operations
- `bash`, `sh` - Shell interpreters
- `cat`, `grep` - Text utilities

**I would use this when:** Looking for system commands or understanding where basic command binaries are located.

---

### `/usr/bin` - User Command Binaries
**Purpose:** Contains the majority of user commands and applications installed by the distribution.

**Hands-on Check:**
```bash
ls /usr/bin | wc -l  # Count how many binaries
which python3
which docker
```

**Common contents:**
- `python3`, `node`, `java` - Programming languages
- `git`, `curl`, `wget` - Development tools
- `vim`, `nano` - Text editors

**I would use this when:** Finding installed applications, checking if a tool is available, or locating command paths for scripts.

---

### `/opt` - Optional/Third-Party Applications
**Purpose:** Reserved for installation of add-on application software packages. Often used for manually installed or commercial software.

**Hands-on Check:**
```bash
ls -l /opt
```

**Common contents:**
- Google Chrome
- Third-party applications
- Custom software installations

**I would use this when:** Installing third-party applications that don't fit the standard `/usr` hierarchy or managing commercial software.

---

## File System Hierarchy Summary Table

| Directory | Purpose | When to Use |
|-----------|---------|-------------|
| `/` | Root of entire filesystem | Understanding absolute paths |
| `/home` | User home directories | Accessing user files and configs |
| `/root` | Root user's home | Admin scripts and root operations |
| `/etc` | System configuration files | Modifying service configs |
| `/var/log` | Log files | Troubleshooting and debugging |
| `/tmp` | Temporary files | Scratch space for scripts/apps |
| `/bin` | Essential system binaries | Basic system commands |
| `/usr/bin` | User application binaries | Installed applications |
| `/opt` | Optional third-party apps | Commercial/custom software |

---

# Part 2: Scenario-Based Practice

## SOLVED EXAMPLE: Understanding How to Approach Scenarios

### Example Scenario: Check if a Service is Running

**Question:** How do you check if the 'nginx' service is running?

**My Solution (Step by step):**

**Step 1:** Check service status
```bash
systemctl status nginx
```
**Why this command?** It shows if the service is active, failed, or stopped. Provides immediate status information.

**Step 2:** If service is not found, list all services
```bash
systemctl list-units --type=service
```
**Why this command?** To see what services exist on the system and verify the correct service name.

**Step 3:** Check if service is enabled on boot
```bash
systemctl is-enabled nginx
```
**Why this command?** To know if it will start automatically after reboot. Helps understand persistent configuration.

**What I learned:** Always check status first, then investigate based on what you see. Start with broad checks, then narrow down.

---

## Scenario 1: Service Not Starting

### Problem Statement
```
A web application service called 'myapp' failed to start after a server reboot.
What commands would you run to diagnose the issue?
Write at least 4 commands in order.
```

### My Solution

**Step 1:** Check if the service is running or failed
```bash
systemctl status myapp
```
**Why:** This shows the current state (active, inactive, failed) and recent log entries. It's the first step in diagnosing service issues.

**Step 2:** Check if the service is enabled to start on boot
```bash
systemctl is-enabled myapp
```
**Why:** If the service is "disabled", it won't start automatically after reboot. This could explain why it's not running.

**Step 3:** View detailed logs for the service
```bash
journalctl -u myapp -n 50
```
**Why:** Shows the last 50 log entries for this specific service. Reveals error messages, stack traces, or configuration problems.

**Step 4:** Check logs since last boot
```bash
journalctl -u myapp -b
```
**Why:** Shows all logs for this service since the system booted. Helps identify if the service failed during startup.

**Step 5:** Try to start the service manually and observe output
```bash
sudo systemctl start myapp
systemctl status myapp
```
**Why:** Attempting to start it manually can reveal immediate errors or configuration issues.

**Step 6:** If still failing, check for port conflicts or dependencies
```bash
sudo netstat -tulpn | grep <port>  # Check if port is already in use
journalctl -xe  # Check system-wide logs for errors
```
**Why:** Services often fail due to port conflicts or missing dependencies.

**What I learned:** Service troubleshooting follows a pattern: status â†’ logs â†’ manual start â†’ dependencies.

---

## Scenario 2: High CPU Usage

### Problem Statement
```
Your manager reports that the application server is slow.
You SSH into the server. What commands would you run to identify
which process is using high CPU?
```

### My Solution

**Step 1:** Get a live view of CPU usage by process
```bash
top
```
**Why:** Shows real-time CPU usage sorted by default. Press 'P' to sort by CPU, 'M' to sort by memory, 'q' to quit.

**Alternative:**
```bash
htop
```
**Why:** More user-friendly with colors and easier navigation (if installed).

**Step 2:** Get a snapshot of top CPU-consuming processes
```bash
ps aux --sort=-%cpu | head -10
```
**Why:** Shows top 10 processes by CPU usage in a snapshot format. Easy to share with team members.

**Step 3:** Note the Process ID (PID) of the problematic process
```bash
# From top or ps output, identify the PID
# For example, if PID is 1234
ps -p 1234 -f
```
**Why:** Get detailed information about the specific process, including the full command that started it.

**Step 4:** Check how long the process has been running
```bash
ps -p 1234 -o pid,etime,cmd
```
**Why:** Understand if this is a runaway process or expected behavior.

**Step 5:** Investigate the process further
```bash
# Check what files the process is using
sudo lsof -p 1234

# Check the process tree
pstree -p 1234
```
**Why:** Understand what the process is doing and what resources it's accessing.

**Step 6:** Monitor CPU usage over time
```bash
# Install and use sar for historical data
sar -u 5 10  # CPU usage, 5-second intervals, 10 times
```
**Why:** Determine if high CPU is constant or intermittent.

**What I learned:** Start with live monitoring tools, identify the problematic process by PID, then investigate its behavior and resource usage.

---

## Scenario 3: Finding Service Logs

### Problem Statement
```
A developer asks: "Where are the logs for the 'docker' service?"
The service is managed by systemd.
What commands would you use?
```

### My Solution

**Step 1:** Check the service status first
```bash
systemctl status docker
```
**Why:** The status output shows the last few log lines and confirms the service is managed by systemd.

**Step 2:** View the last 50 lines of logs
```bash
journalctl -u docker -n 50
```
**Why:** `-u` specifies the unit (service), `-n 50` limits to last 50 lines. Quick way to see recent activity.

**Step 3:** Follow logs in real-time (like tail -f)
```bash
journalctl -u docker -f
```
**Why:** `-f` follows the log output live. Useful for watching what happens when you perform an action.

**Step 4:** View logs since a specific time
```bash
# Logs from the last hour
journalctl -u docker --since "1 hour ago"

# Logs from today
journalctl -u docker --since today

# Logs from specific date/time
journalctl -u docker --since "2026-02-05 10:00:00"
```
**Why:** Narrow down logs to a specific time window when an issue occurred.

**Step 5:** View logs with priority level (errors only)
```bash
journalctl -u docker -p err
```
**Why:** `-p err` shows only error-level messages. Helps filter out noise.

**Step 6:** Export logs to a file for sharing
```bash
journalctl -u docker -n 100 > docker_logs.txt
```
**Why:** Developers can analyze logs offline or share them with the team.

**Alternative for non-systemd services:**
```bash
# Check traditional log locations
ls -l /var/log/docker/
tail -f /var/log/docker/docker.log
```

**What I learned:** For systemd services, `journalctl` is the primary tool. Use `-u` for service-specific logs, `-f` for live monitoring, and `--since` for time-based filtering.

---

## Scenario 4: File Permissions Issue

### Problem Statement
```
A script at /home/user/backup.sh is not executing.
When you run it: ./backup.sh
You get: "Permission denied"

What commands would you use to fix this?
```

### My Solution

**Step 1:** Check current permissions
```bash
ls -l /home/user/backup.sh
```
**Why:** Verify what permissions the file currently has. Look for the permission string at the beginning.

**Example output:**
```
-rw-r--r-- 1 user user 1024 Feb 05 10:00 /home/user/backup.sh
```
**Analysis:** `-rw-r--r--` means:
- Owner can read and write (`rw-`)
- Group can read (`r--`)
- Others can read (`r--`)
- **No execute permission** (`x`) for anyone â†’ This is the problem!

**Step 2:** Add execute permission
```bash
chmod +x /home/user/backup.sh
```
**Why:** `+x` adds execute permission for owner, group, and others. This allows the script to be run.

**Alternative (more specific):**
```bash
chmod u+x /home/user/backup.sh  # Execute for owner only
chmod 755 /home/user/backup.sh  # rwxr-xr-x (owner full, others read+execute)
```

**Step 3:** Verify the change worked
```bash
ls -l /home/user/backup.sh
```
**Expected output:**
```
-rwxr-xr-x 1 user user 1024 Feb 05 10:00 /home/user/backup.sh
```
**Why:** Confirm that `x` permission is now present. The first set `rwx` shows owner has read, write, and execute.

**Step 4:** Try running the script
```bash
./backup.sh
```
**Why:** Test that the permission fix resolved the issue.

**Step 5:** Additional checks if still failing
```bash
# Check if the script has the correct shebang
head -1 /home/user/backup.sh
# Should see something like: #!/bin/bash

# Check if you're the owner
stat /home/user/backup.sh

# Check if SELinux is blocking (on RedHat/CentOS)
getenforce
```

**What I learned:** Always check permissions with `ls -l` first. Scripts need execute (`x`) permission to run. Use `chmod +x` to add execute permission. Verify changes before testing.

---

## Permission Modes Reference Table

| Symbolic | Numeric | Meaning |
|----------|---------|---------|
| `-rw-------` | 600 | Owner can read/write |
| `-rwx------` | 700 | Owner can read/write/execute |
| `-rw-r--r--` | 644 | Owner read/write, others read only |
| `-rwxr-xr-x` | 755 | Owner full, others read/execute |
| `-rwxrwxrwx` | 777 | Everyone full access (dangerous!) |

---

# Troubleshooting Flow Summary

## General Approach for Any Issue

1. **Identify the Problem**
   - What is the expected behavior?
   - What is the actual behavior?
   - When did it start?

2. **Check the Basics**
   - Is the service running?
   - Are there any recent changes?
   - What do the logs say?

3. **Gather Information**
   - Use status commands
   - Check logs (journalctl or /var/log)
   - Monitor resource usage

4. **Form a Hypothesis**
   - Based on logs and symptoms
   - What could cause this behavior?

5. **Test the Hypothesis**
   - Try a fix
   - Verify the result
   - Document what worked

6. **Document the Solution**
   - What was the problem?
   - What fixed it?
   - How to prevent it?

---

# Key Commands Reference

## Service Management
```bash
systemctl status <service>      # Check service status
systemctl start <service>       # Start a service
systemctl stop <service>        # Stop a service
systemctl restart <service>     # Restart a service
systemctl enable <service>      # Enable on boot
systemctl disable <service>     # Disable on boot
systemctl is-enabled <service>  # Check if enabled
systemctl list-units --type=service  # List all services
```

## Log Viewing
```bash
journalctl -u <service>         # View logs for a service
journalctl -u <service> -n 50   # Last 50 lines
journalctl -u <service> -f      # Follow logs (real-time)
journalctl -u <service> -b      # Logs since last boot
journalctl -u <service> --since "1 hour ago"  # Time-based
journalctl -p err               # Error-level only
journalctl -xe                  # Recent logs with explanations
```

## Process Monitoring
```bash
top                             # Interactive process viewer
htop                            # Enhanced top (if installed)
ps aux                          # List all processes
ps aux --sort=-%cpu | head -10  # Top 10 CPU users
ps aux --sort=-%mem | head -10  # Top 10 memory users
ps -p <PID> -f                  # Details of specific process
pstree -p <PID>                 # Process tree
lsof -p <PID>                   # Files opened by process
```

## File Permissions
```bash
ls -l <file>                    # Check permissions
chmod +x <file>                 # Add execute permission
chmod 755 <file>                # Set specific permissions
chmod u+x <file>                # Execute for owner only
chown user:group <file>         # Change ownership
stat <file>                     # Detailed file info
```

## File System Navigation
```bash
ls -la                          # List all files (including hidden)
du -sh /var/log/*               # Check directory sizes
df -h                           # Check disk space
find /path -name "*.log"        # Find files by name
tree /etc/nginx                 # Visual directory tree
```

---

# Why This Matters for DevOps

## Understanding File System is Critical For:
- âœ… **Finding logs** when services fail
- âœ… **Locating configuration files** for applications
- âœ… **Understanding where binaries** are installed
- âœ… **Writing scripts** that work across different systems
- âœ… **Troubleshooting deployment** issues
- âœ… **Security auditing** and access control

## Scenario-Based Practice Prepares You For:
- âœ… **Real production incidents** - When services go down at 2 AM
- âœ… **DevOps interviews** - These exact scenarios are asked
- âœ… **On-call troubleshooting** - Under pressure with time constraints
- âœ… **Collaborating with developers** - Speaking the same language
- âœ… **Documentation** - Writing runbooks and procedures

---

# Practice Exercises (Bonus)

## Exercise 1: Log Investigation
```bash
# Find all error logs in the last hour
journalctl --since "1 hour ago" -p err

# Find the 5 largest files in /var/log
du -ah /var/log | sort -h | tail -5

# Search for "error" in all log files
grep -r "error" /var/log/ 2>/dev/null | head -20
```

## Exercise 2: Service Deep Dive
```bash
# Pick any service (e.g., ssh)
systemctl status ssh
journalctl -u ssh -n 100
systemctl show ssh  # Show all properties
systemctl cat ssh   # Show unit file
```

## Exercise 3: Permission Challenge
```bash
# Create a test script
echo '#!/bin/bash' > test.sh
echo 'echo "Hello DevOps!"' >> test.sh

# Try to run it (will fail)
./test.sh

# Fix permissions
chmod +x test.sh

# Run it (will succeed)
./test.sh
```

---

# Key Takeaways

1. **File System Hierarchy** - Know where things live in Linux
2. **Logs are Critical** - `/var/log` and `journalctl` are your best friends
3. **Troubleshooting is a Process** - Follow a systematic approach
4. **Permissions Matter** - Check `ls -l` when scripts won't run
5. **Practice Makes Perfect** - These scenarios will become second nature

---
